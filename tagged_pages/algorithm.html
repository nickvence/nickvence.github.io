<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pages tagged algorithm | Applied Stats</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://nickvence.github.io/tagged_pages/algorithm.html">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../">

            <span id="blog-title">Applied Stats</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../research.html" class="nav-link">Research</a>
                </li>
<li class="nav-item">
<a href="../posts/index.html" class="nav-link">Blog</a>
                </li>
<li class="nav-item">
<a href="../galleries/graph/" class="nav-link">Gallery</a>
                </li>
<li class="nav-item">
<a href="../about.html" class="nav-link">About</a>
                </li>
<li class="nav-item">
<a href="../categories/index.html" class="nav-link">Tags</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        

    <header><h1>Pages tagged algorithm</h1>
        <div class="metadata">
            

            

        </div>
    </header><div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../madness.html" class="u-url">MADNESS</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nicholas Vence
            </span></p>
            <p class="dateline">
            <a href="../madness.html" rel="bookmark">
            <time class="published dt-published" datetime="2021-01-15T16:30:56-05:00" itemprop="datePublished" title="2021-01-15">2021-01-15</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<div class="section" id="introduction">
<h3>Introduction</h3>
<div class="figure align-right" style="width: 450px">
<img alt="Different 3D mesh resolutions." src="../files/3Dmesh.jpg" style="width: 450px;"><p class="caption"><strong>Fig. 1</strong> The number of boxes in a three-dimensional, finite-element grid is
vastly different for a slightly different resolutions: see the numbers in table.</p>
</div>
<p>Partial differential equations (PDE) are used to approximate solutions to a variety of
real world problems.
MADNESS (Multiresolution ADaptive Numerical Environment for Scientific Simulation) is
a framework written in C++ for solving differential (and integral) equations efficiently
on high performance computers (HPC).</p>
<p>A first step to learning MADNESS is understanding the most popular model for solving PDEs:
the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_element_method">finite element method</a> scheme which discretizes space (dividing it into boxes) and then
creates functions and operators to approximate the solution on the mesh (the discretized space).
While this popular approach works for a wide variety of problems, it breaks down for
high-dimensional problems that requires resolution at multiple length-scales.</p>
<table class="float-left m-4 table-sm table-striped">
<caption>Memory usage as a function of <span class="math">\(N_{size}\)</span>.</caption>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr>
<td><p>\[N_{side}\]</p></td>
<td><p>\[N_{total}\]</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>64</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>216</p></td>
</tr>
<tr>
<td><p>8</p></td>
<td><p>512</p></td>
</tr>
<tr>
<td><p>10</p></td>
<td><p>1000</p></td>
</tr>
</tbody>
</table>
<p>As a practical example, suppose you are interested in modeling
three dimensional (3D) water waves on a finite element grid. DEFINE BOX as ELEMENT
Now suppose you need to include the interaction of the large ocean waves with the
small waves of an outboard motor; this is a problem with multiple length scales.
Large waves require a large total simulation volume, while small waves require a tiny volume units.
This combination uses lots of memory, and will scale poorly when increasing the resolution.
The memory footprint is proportional to the total number of boxes or elements <span class="math">\(N_{total}\)</span>, for</p>
<p>\[\text{Memory size} = O(N_{side}^3). \]</p>
<p>A high-dimensional, high-resolution problem is the weakness of the finite element method.
When possible, it is advantagous to use the fewest number of dimensions that adequately
capture the phenomenon. For instance, given a spherically symmetric electron cloud in the
presence of a linearly-polarized electric field, cylindrical symmetry is imposed on the
system. This makes a 2D simulation is sufficient; an elliptically-polarized laser,
however, breaks the cylindrical symmetry requiring a 3D simulation.</p>
<p>1D and most 2D problems can be solved on personal computers; however, when increasing
complexity outpaces the abilities of a personal computer, small workstations (or cloud
computing) are the next solution.  These use multiple of processors (with dozens
of computing cores) and can be built with over 100 GB of shared memory. In shared memory
computers, memory size (or processing power) is the bottleneck.
However, some simulations (supernova, weather, molecular dynamics, etc.) require the
largest computers, and these use distributed memory.
In these systems, interprocessor communication becomes the bottleneck.
While supercomputers will always be improving bus speeds, fiber optic interconnects,
network topology, and routing algorithms; users must create code to take advantage of
these technologies.</p>
</div>
<div class="section" id="madness-a-multiresolution-adaptive-mesh">
<h3>MADness: a Multiresolution ADaptive mesh</h3>
<div class="figure align-right" style="width: 350px">
<img alt="A multiresolution mesh" src="../files/madness1.png" style="width: 300px;"><p class="caption"><strong>Fig. 2</strong> A multiresolution mesh has more than one size box in the grid,
and an adaptive grid places extra grid points just where they are needed.</p>
</div>
<p>One way of solving the issue of multiple length-scales on a high-dimensional
domain is to introduce a multiresolution (variable-size) mesh
shown in Fig. 2.  Multiresolution is the M in the MADNESS acronym.</p>
<p>Multiresolution grid placement is challenge: will small ripples
stay in one place or will they move over time?
To solve this issue, MADNESS uses an ADaptive (mADness) mesh:
one that changes to meet the needs of the function being modeled. If you're
interested in the mathematical details of adaptive refinement, see section 2.1
of our <a class="reference external" href="https://amath.colorado.edu/faculty/beylkin/papers/H-B-B-C-F-F-G-etc-2016.pdf">SIAM Publication</a>.</p>
</div>
<div class="section" id="madness-a-numerical-environment-for-scientific-simulation">
<h3>madNESS: a Numerical Environment for Scientific Simulation</h3>
<p>This numerical environment for scientific simulation (madNESS) consists of the following
features:</p>
<ul class="simple">
<li><p>A library of fast, arbitrarily-accurate math functions acting on simulation-domain functions.</p></li>
<li><p>The illusion of "basis-free" computing.</p></li>
<li><p>A parallel runtime environment engineered for load balancing on hundreds of thousands of cores.</p></li>
<li><p>An overview of the HPC libraries upon which MADNESS is based.</p></li>
</ul>
<div class="sidebar">
<p class="sidebar-title">Case Study</p>
<p class="sidebar-subtitle">Poorly-designed software</p>
<p>In the early days, much was learned about engineering HPC applications by trial and error.
For instance, when writing a 3D finite element algorithm on a 64 CPU-cluster,
one might naively allocate 1 CPU for each element of a 4x4x4 grid (see Fig. 1).
This poor design-choice locks the hardware to the simulation-parameters,
limiting code portability and a future growth in computing power: <a class="reference external" href="https://en.wikipedia.org/wiki/Moore's_law">Moore's Law</a>.</p>
<p>Many HPC applications are writen by scientists working outside their domain of expertice.
Over the years HPC frameworks have evolved to ease the transition, and MADNESS
has had the benefit of standing on the shoulders of giants.
One such luxury is having computational objects
that directly correspond to terms in the equation we are modeling.
Other HPC frameworks, by contrast, force programers to work with computational
objects that are non-physical abstractions (e.g. processorID).
These hurdles make HPC development needlessly complex.</p>
</div>
<div class="section" id="hpc-api">
<h4>HPC API</h4>
<p>A 3D finite-element scheme stores the data of the simulation function
(ocean waves, or electron wave function) in a fixed, 3D array.
MADNESS functions, due to their adaptive nature are stored as a tree.
To facilitate fast, guaranteed precision math on this tree,
MADNESS provides an application programming interface (API)
for common operations for functions of one to six dimensions.
These operations include: arithmetic, linear algebra, numerical
differentiation, and integral convolution.
This API enables the creation of code that often reads like the
math equation that it is modeling. For an example see section 3 of the <a class="reference external" href="https://amath.colorado.edu/faculty/beylkin/papers/H-B-B-C-F-F-G-etc-2016.pdf">SIAM publication</a>.</p>
</div>
<div class="section" id="basis-free-computing">
<h4>"Basis-free" computing</h4>
<p>Many simple chemical systems are efficiently modeled using a molecular-orbit basis.
These basis functions reflect the symmetry of the system, and chemical processes near the
ground state are accurately described with just a few molecular-orbital basis functions.
This is referred to as a sparse basis, and is computationally beneficiais computationally beneficial</p>
<p>While a sparse basis makes for efficient computation, it has a dark side: basis error.
For low-energy processes (between the ground state and first excited state), the
basis error is small. However, as higher-energy chemical processes involve
more exotic excitations more basis functions are requred which amplifies
basis error. For these systems, MADNESS (like a finite element scheme)
becomes an attractive solution that doesn't have basis error.
However, being more memory-efficient, MADNESS outperforms the finite elements scheme
which is seen as a dense solution to the problem.</p>
</div>
<div class="section" id="load-balancing">
<h4>Load-balancing</h4>
<p>There are physical limits on processor speed;
for this reason, HPC is synonymous with distributed computing.
Today, the most powerful computers have the most processors.
Computers with thousands of available processors are no longer rare at universities and government labs.
However, writing efficient code to make use of these computers is a challenge.</p>
<p>An important test for HPC software is the <strong>scaling test</strong>: benchmarking
code speed as a function of the number of processors on which it is run.
Creating code whose speed scales linearly with the number of processors is the main goal in HPC.
IMPROVE SENTENCE Scaling measures the efficiency of processor use.  While more processors usually brings more speed,
in reality the law of diminishing returns eventually takes over.</p>
<p>MADNESS successfully scales to thousands of processors;
this is due in part to its internal compartmentalization of work for
its task-queue that is designed to hide interprocessor communication latency.
To learn more about the task queue read section 4 of the <a class="reference external" href="https://amath.colorado.edu/faculty/beylkin/papers/H-B-B-C-F-F-G-etc-2016.pdf">SIAM publication</a>.</p>
</div>
<div class="section" id="hpc-libraries">
<h4>HPC Libraries</h4>
<p>Creating code that can take advantage of modern supercomputers can be a career.
Unfortunately, most scientists already have a career, and can't afford to put it
on hold while mastering distributed computing software development.
The following technologies allow average programmers (through MADNESS)
to leverage industry standard:</p>
<ul class="simple">
<li><p><strong>Global Arrays</strong> an API for shared memory programming on distributed memory computers.</p></li>
<li><p><strong>MPI</strong> Message Passing Interface for distributed-memory parallel programming.</p></li>
<li><p><strong>OpenMP</strong> an interface to shared-memory parallel programming.</p></li>
<li><p><strong>Pthreads</strong> a thread execution model governing non-concurrent bundles of computation.</p></li>
<li><p><strong>Futures</strong> a C++ standard providing synchronization across threads.</p></li>
</ul>
</div>
</div>
<div class="section" id="publications">
<h3>Publications</h3>
<p>The <a class="reference external" href="https://amath.colorado.edu/faculty/beylkin/papers/H-B-B-C-F-F-G-etc-2016.pdf">SIAM publication</a> is a scholarly introduction to the mathematics of MADNESS
that describes the distributed computing technologies it relies on and reviews some scientific applications.</p>
<p>My Physics Review A <a class="reference external" href="../files/Vence01PRA.pdf">publication</a> solves the time-dependent Schrodinger equation in a strong laser field
using MADNESS.  It provides an introduction to  MADNESS to the atomic physics community.</p>
<p>Here is a brief, 15-minute overview of MADNESS from its founder Robert Harrison.</p>
<div class="youtube-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/dBwWjmf5Tic?rel=0&amp;wmode=transparent" frameborder="0" allow="encrypted-media" allowfullscreen></iframe>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../proton-computed-tomography.html" class="u-url">Proton Computed Tomography</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Nicholas Vence
            </span></p>
            <p class="dateline">
            <a href="../proton-computed-tomography.html" rel="bookmark">
            <time class="published dt-published" datetime="2021-01-08T11:00:40-05:00" itemprop="datePublished" title="2021-01-08">2021-01-08</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<div class="section" id="background">
<h3>Background</h3>
<div class="figure align-right" style="width: 450px">
<img alt="Comparing radiation-depth profiles: protons, x-rays, carbon" src="../files/bragg.png" style="width: 400px;"><p class="caption"><strong>Fig. 1</strong> The radiation depth profile.
X-rays decay exponentially with depth.
Protons deposit most of their energy just before stopping at the Bragg Peak.
Carbon ions have less entry radiation and a sharper Bragg peak, but
the damage they do behind the Bragg peak limits their usefulness.</p>
</div>
<p class="lead">Cancer is the second leading cause of death in the Western world.
While surgery and chemotherapy can cure patients, these treatments
are often augmented with radiation.
Two of the common radiation modalities onocologists to choose from are x-rays and proton therapy.</p>
<p><em>X-rays</em> are the easiest to produce, making them the inexpensive choice; however,
their radiation damage profile is exponential with depth (see Fig. 1).
That is, they deposit most of their radiation near the surface.
Thus, physicians must spread out radiation delivery to give the tumor
the largest dose without burning the skin.</p>
<p><em>Protons</em> deliver the most tissue damage just before they stop; this is
called the Bragg peak (see Fig. 1).
The Bragg peak makes proton radiation a useful tool in treating
head and neck tumors which are often surrounded by vital organs.
For these situations, minimizing the treatment volume is
often the difference between treatment and no treatment:
the difference between life and death.</p>
<p>Proton Computed Tomography (pCT) will offer two unique advantages to
patients getting treated with proton radiation.
The first advantage is simple: pCT gives a lower radiation dose
than that of x-ray Computed Tomography (xCT); however, this not the primary
advantage.</p>
<p>To understand the primary advantage, it helps to know that
radiation treatment planning requires a 3D image of the tumor,
and currently, the only option is an xCT.
It is probably not surprising that x-rays (which are photons) stop
differently than protons (heavy, sub-atomic particles).
This stopping-power difference is unfortunate because it means the
3D image (of x-ray stopping power) produced by the xCT is an ambiguous map
for the stopping power of proton radiation.
This translates into an increased margin of error for the depth of the protons
which creates a larger treatment-volume. In the case of space-restricted tumors
in the head and neck.</p>
<p>To avoid relapse in the cancer that caused the tumor,
doctors apply a margin of error around the tumor to
be sure its undetected SPELL tenticles are destroyed. For tumors far
from vital organs, this acceptable: the body will
recover from the radiation damage. However, tumors in the head
and neck are often located too close to vital organs; that is,
there is no room for doctors to prescribe the appropriate radiation
margin.  Unfortunately, these patients are denied treatment.</p>
<p>By eliminating the differential stopping power between xCT and pCT,
oncologists will be able to perscribe smaller tumor margins. This means
all patients will receive a lower radiation dose, and
fewer patients will be denied treatment.</p>
</div>
<div class="section" id="the-scanner">
<h3>The Scanner</h3>
<div class="figure align-right" style="width: 400px">
<img alt="The proton Computed Tomography scanner." src="../files/pct3.png" style="width: 400px;"><p class="caption"><strong>Fig. 2</strong> (Upper) Photo of the phase 2 proton Computed Tomography scanner.
(Lower) A representative proton path traveling through the forward position detector,
head-phantom, rear position detector, and into the energy detector of the phase 1 scanner.</p>
</div>
<div class="figure align-right" style="width: 400px">
<img alt="Calibration phantom" src="../files/callibration.png" style="width: 400px;"><p class="caption"><strong>Fig. 3</strong> The calibration phantom (orange) is shown between the tracker planes
(and in the inset). The proton's final destination is the numbered, yellow,
scintillating energy detectors.</p>
</div>
<p>The pCT scanner consists of two parts:
the proton energy detector and the proton tracker.</p>
<p>The tracker is a silicon strip detector (SSD) charged with a moderate voltage. EXPLAIN BETTER
When hit by a proton, scattered electrons flow down the strips and registering the coordinate.
A position requires an x and y coordinate, and two positions are needed to record an angle.
Thus, to measure the incoming and outgoing angle, the proton must pass through eight SSD detectors.</p>
<p>As the proton brakes to a stop, the scintillating energy detector gives off light.
The proton stops in a series of five cesium-iodide (CsI) crystals.
Each are wrapped in reflective tape and connected to photomultiplier tubes whose signal
is processed to determine the proton's energy.</p>
</div>
<div class="section" id="energy-calibration">
<h3>Energy Calibration</h3>
<p>I worked with the calibration of the energy detector
which involved the following steps:</p>
<ul class="simple">
<li><p>Create low-intensity proton beam.</p></li>
<li><p>Take data with calibration phantom (see Fig. 3).</p></li>
<li><p>Reconstruct proton path from tracker data.</p></li>
<li><p>Determine the distance traveled in the calibration phantom.</p></li>
<li><p>Correlate this distance to light output.</p></li>
</ul>
<p>For calibration, we need a low-intensity proton beam so that we are SPELL predominantly measuring
single-proton events.</p>
<p>The calibration phantom shown in Fig. 3 was designed to spread uniformly energetic protons
into energies that may be predicted by their path.
A stepped triangular prism provides an surface on which error in the tracker will not greatly
affect the detector path length.
The tracker phantom has four removable blocks which allow us to create protons
with energies across our detectable range.</p>
<p>The reconstruction of the proton path turns detector data into an entrance and exit ray.
A proton event is eight SSD coordinants and the light output of the five energy detectors.
First, tracker data is transformed from SSD strip number into detector coordinates SPELL.
Periodically the incoming and outgoing rays would be misaligned, these events are attributed
to proton scattering and discarded.
The reconstruction of the remaining nearly-collinear rays, was solved to a series of linear equations.</p>
<p>The next step was finding the intersection of this geometric path with the
calibration phantom, and converting it into the standard unit of stopping power:
the water equivalent path length (WEPL).  Determining this intersection was tedious,
given the intricate triangular steps of the calibration phantom.</p>
<p>Because a proton deposits the maximum energy just before stopping (the Bragg peak),
we maximize the precision of our energy measurement by calibrating with the light
from the deepest crystal that contains the Bragg peak. IMPROVE</p>
</div>
<div class="section" id="summary">
<h3>Summary</h3>
<p>REMOVE
Reinhard Schulte, our project's principle investigator, created the phase 0 scanner
to include in his R01 grant application; it was made from spare parts and was added to improve
the chances of his grant success. It worked; this proof of concept convinced
the grant comittee of the project's viability. NOT NECESSARY</p>
<p>COMBINE
Much more care and engineering went into the design of the phase 1 scanner.
However, it was charactirized by its data acquisition bottleneck, and scans took between five and six hours.
One can imagine how difficult this ordeal would be for a human receiving such a scan.</p>
<p>Among the many improvements in the phase 2 scanner was a series of custom designed
integrated circuits to process current bursts from individual proton events on a single chip.
This allowed us to take data at about 1 MHz which reduced the total scan time to between
five and ten minutes.</p>
</div>
<div class="section" id="pulbications">
<h3>Pulbications</h3>
<ul class="simple">
<li><p><a class="reference external" href="../files/Vence03.pdf">Track Reconstruction with the Silicon Strip Tracker of the Proton CT Phase 2 Scanner</a></p></li>
<li><p><a class="reference external" href="https://www.redjournal.org/article/S0360-3016(15)00966-9/abstract">First experimental results</a></p></li>
<li><p><a class="reference external" href="https://www.thegreenjournal.com/article/S0167-8140(15)40407-4/pdf">Design and performance of a preclinical proton CT head scanner</a></p></li>
</ul>
</div>
</div>
    </div>
    </article>
</div>





        
        <script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script><script>
                renderMathInElement(document.body,
                    {
                        
delimiters: [
    {left: "$$", right: "$$", display: true},
    {left: "\\[", right: "\\]", display: true},
    {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
    {left: "$", right: "$", display: false},
    {left: "\\(", right: "\\)", display: false}
]

                    }
                );
            </script><!--End of body content--><footer id="footer">
            Contents © 2021         <a href="mailto:nickvence@gmail.com">Nicholas Vence</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
